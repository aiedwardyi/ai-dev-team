import { Project, Artifact, LogEntry, AgentStage, EngineerTask } from "../types";
import { v4 as uuidv4 } from 'uuid';

const API_BASE = 'http://localhost:5000/api';

function normalizePrd(raw: any) {
  const prd = raw?.prd || raw;
  return {
    title: prd.document_title || prd.title || 'Product Requirements Document',
    summary: prd.overview || prd.summary || '',
    features: prd.core_features_mvp || prd.features || prd.goals || [],
    userStories: prd.user_stories || prd.userStories || [],
    techStackRecommendation: prd.technical_stack_recommendation || prd.techStackRecommendation || [],
  };
}

function normalizePlan(raw: any) {
  // Handle both flat { milestones } and wrapped { plan: { milestones } } shapes
  const milestones = raw?.milestones || raw?.plan?.milestones || raw?.phases || [];
  return {
    phases: milestones.map((m: any) => ({
      name: m.name || 'Milestone',
      description: (m.tasks || []).map((t: any) => t.description).join(' · ') || '',
      steps: (m.tasks || []).map((t: any) => t.description || t.id || 'Task'),
    })),
    estimatedTimeline: `${milestones.length} milestone${milestones.length !== 1 ? 's' : ''}`,
  };
}

function normalizeCode(raw: any) {
  const outputs = raw?.outputs || {};
  const writes = outputs.writes || [];
  const summary = outputs.summary || 'Engineer agent execution complete.';
  const files = writes.map((w: any) => {
    const fullPath: string = w.path || '';
    const filename = fullPath.split('\\').pop() || fullPath.split('/').pop() || 'file';
    const ext = filename.split('.').pop()?.toLowerCase() || '';
    const langMap: Record<string, string> = {
      py: 'python', js: 'javascript', ts: 'typescript', tsx: 'tsx', jsx: 'jsx',
      md: 'markdown', txt: 'plaintext', json: 'json', yml: 'yaml', yaml: 'yaml',
      html: 'html', css: 'css', sh: 'bash', gitignore: 'plaintext',
    };
    return {
      filename,
      language: langMap[ext] || 'plaintext',
      content: `// ${filename}\n// Generated by Engineer Agent\n// Size: ${w.bytes} bytes\n// SHA256: ${w.sha256}\n\n// Full path: ${fullPath}`,
    };
  });
  return {
    files: [
      {
        filename: '_summary.md',
        language: 'markdown',
        content: `# Engineer Agent Execution Summary\n\n${summary}\n\n## Generated Files (${writes.length})\n\n${writes.map((w: any) => `- ${w.path.split('\\').pop() || w.path} (${w.bytes} bytes)`).join('\n')}\n\n## Agent Sequence\n\n${(raw?._agent_sequence || []).join(' → ')}\n\n## Produced At\n\n${raw?._meta?.produced_at || 'Unknown'}`,
      },
      ...files,
    ],
  };
}

function normalizeProject(raw: any): Project {
  return {
    ...raw,
    id: String(raw.id),
    createdAt: raw.createdAt ?? (raw.created_at ? new Date(raw.created_at).getTime() : Date.now()),
    status: raw.status?.toUpperCase() === 'COMPLETED' ? 'COMPLETED'
          : raw.status?.toUpperCase() === 'FAILED' ? 'FAILED'
          : raw.status === 'in_progress' || raw.status?.toUpperCase() === 'RUNNING' ? 'RUNNING'
          : 'IDLE',
    currentStage: raw.currentStage || 'idle',
    engineerTasks: raw.engineerTasks || [],
  };
}

function buildTasksFromResult(raw: any): EngineerTask[] {
  const writes = raw?.outputs?.writes || [];
  const producedAt = raw?._meta?.produced_at ? new Date(raw._meta.produced_at).getTime() : Date.now();
  return writes.map((w: any, i: number) => {
    const fullPath: string = w.path || '';
    const filename = fullPath.split('\\').pop() || fullPath.split('/').pop() || `file-${i}`;
    return {
      id: uuidv4(),
      filename,
      timestamp: producedAt + i * 100,
      description: `Generated ${filename} (${w.bytes} bytes)`,
    };
  });
}

class BackendService {
  private projects: Project[] = [];
  private artifacts: Artifact[] = [];
  private logs: LogEntry[] = [];
  private listeners: (() => void)[] = [];
  private pollingIntervals: Map<string, any> = new Map();
  private isConnected: boolean = false;
  private artifactExecutionIds: Map<string, string> = new Map();

  constructor() {
    this.silentFetchProjects();
  }

  subscribe(callback: () => void) {
    this.listeners.push(callback);
    return () => { this.listeners = this.listeners.filter(l => l !== callback); };
  }

  private notify() { this.listeners.forEach(l => l()); }

  private async silentFetchProjects() {
    try {
      const response = await fetch(`${API_BASE}/projects`);
      if (response.ok) {
        this.projects = (await response.json()).map(normalizeProject);
        this.isConnected = true;
      } else {
        this.isConnected = false;
      }
    } catch {
      this.isConnected = false;
    } finally {
      this.notify();
    }
  }

  async fetchProjects() {
    try {
      const response = await fetch(`${API_BASE}/projects`);
      if (!response.ok) throw new Error("API Error");
      this.projects = (await response.json()).map(normalizeProject);
      this.isConnected = true;
      this.notify();
    } catch {
      this.isConnected = false;
      this.notify();
    }
  }

  getIsConnected() { return this.isConnected; }
  async retryConnection() { await this.fetchProjects(); }
  getProjects() { return [...this.projects].sort((a, b) => b.createdAt - a.createdAt); }
  getProject(id: string) { return this.projects.find(p => p.id === id); }
  getArtifacts(projectId: string) { return this.artifacts.filter(a => a.projectId === projectId).sort((a, b) => a.createdAt - b.createdAt); }
  getLogs(projectId: string) { return this.logs.filter(l => l.projectId === projectId).sort((a, b) => a.timestamp - b.timestamp); }

  async createProject(name: string, description: string) {
    try {
      const response = await fetch(`${API_BASE}/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, description })
      });
      if (!response.ok) throw new Error("Create failed");
      const newProject = normalizeProject(await response.json());
      this.projects.push(newProject);
      this.isConnected = true;
      this.notify();
      return newProject;
    } catch {
      this.isConnected = false;
      this.notify();
      throw new Error("Backend not connected.");
    }
  }

  async deleteProject(id: string) {
    try {
      await fetch(`${API_BASE}/projects/${id}`, { method: 'DELETE' });
    } catch (e) {
      console.warn("Delete API call failed", e);
    }
    this.projects = this.projects.filter(p => p.id !== id);
    this.artifacts = this.artifacts.filter(a => a.projectId !== id);
    this.logs = this.logs.filter(l => l.projectId !== id);
    this.artifactExecutionIds.delete(id);
    this.notify();
  }

  public addLog(projectId: string, message: string, type: LogEntry['type']) {
    this.logs.push({ id: uuidv4(), projectId, timestamp: Date.now(), message, type });
    this.notify();
  }

  public injectSimulatedError(projectId: string) {
    this.addLog(projectId, "Simulated Error: Backend connection unstable", 'error');
  }

  public clearErrors(projectId: string) {
    this.logs = this.logs.filter(l => !(l.projectId === projectId && l.type === 'error'));
    this.notify();
  }

  public async fixError(projectId: string, logId: string) {
    this.logs = this.logs.filter(l => l.id !== logId);
    this.addLog(projectId, "Agent patching: Error resolved locally", 'info');
    await new Promise(r => setTimeout(r, 1000));
    this.addLog(projectId, "Recovery Successful", 'success');
  }

  async startExecution(projectId: string) {
    const project = this.getProject(projectId);
    if (!project) return;

    this.artifacts = this.artifacts.filter(a => a.projectId !== projectId);
    this.logs = this.logs.filter(l => l.projectId === projectId && l.message.startsWith('User:'));
    this.artifactExecutionIds.delete(projectId);

    project.status = 'RUNNING';
    project.currentStage = 'pm';
    project.engineerTasks = [];
    this.notify();

    try {
      const res = await fetch(`${API_BASE}/execute-task`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ project_id: parseInt(projectId, 10) })
      });
      if (!res.ok) throw new Error("Execution failed");
      this.startPolling(projectId);
    } catch (e) {
      this.isConnected = false;
      this.addLog(projectId, "Backend not connected. Please start Flask server.", 'error');
      project.status = 'FAILED';
      this.notify();
    }
  }

  private startPolling(projectId: string) {
    if (this.pollingIntervals.has(projectId)) clearInterval(this.pollingIntervals.get(projectId));

    const interval = setInterval(async () => {
      try {
        const res = await fetch(`${API_BASE}/execution-status?project_id=${projectId}`);
        if (!res.ok) throw new Error("Poll failed");

        const data = await res.json();
        const project = this.getProject(projectId);
        if (!project) { clearInterval(interval); return; }

        project.status = data.status;
        project.currentStage = data.currentStage;
        project.engineerTasks = data.engineerTasks || [];

        // Merge live server logs into local logs for this project
        if (data.logs && data.logs.length > 0) {
          const serverLogs: LogEntry[] = data.logs.map((l: any) => ({
            id: l.id || uuidv4(),
            projectId,
            timestamp: l.timestamp || Date.now(),
            message: l.message,
            type: l.type || 'info',
          }));
          const userLogs = this.logs.filter(l => l.projectId === projectId && l.message.startsWith('User:'));
          const otherLogs = this.logs.filter(l => l.projectId !== projectId);
          // Deduplicate by message content to avoid duplicates across polls
          const seen = new Set<string>();
          const merged = [...otherLogs, ...userLogs, ...serverLogs].filter(l => {
            const key = `${l.projectId}-${l.message}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          });
          this.logs = merged.sort((a, b) => a.timestamp - b.timestamp);
        }

        await this.syncArtifacts(projectId, project.currentStage, project.status, data.execution_id);
        this.notify();

        if (data.status === 'COMPLETED' || data.status === 'FAILED') {
          clearInterval(interval);
          this.pollingIntervals.delete(projectId);
        }
      } catch (e) {
        console.warn("Polling failed", e);
        this.isConnected = false;
        this.notify();
      }
    }, 2000);

    this.pollingIntervals.set(projectId, interval);
  }

  private async syncArtifacts(projectId: string, stage: AgentStage, status: string, executionId?: string) {
    const cacheKey = executionId ? `${projectId}-${executionId}` : projectId;
    const lastKey = this.artifactExecutionIds.get(projectId);

    if (executionId && lastKey !== cacheKey) {
      this.artifacts = this.artifacts.filter(a => a.projectId !== projectId);
      this.artifactExecutionIds.set(projectId, cacheKey);
    }

    const fetchArtifact = async (
      type: Artifact['type'], endpoint: string, title: string, agent: string,
      normalize: (raw: any) => any
    ) => {
      const exists = this.artifacts.some(a => a.projectId === projectId && a.type === type);
      if (!exists) {
        try {
          const res = await fetch(`${API_BASE}/${endpoint}?project_id=${projectId}`);
          if (res.ok) {
            const content = normalize(await res.json());
            this.artifacts.push({ id: uuidv4(), projectId, type, title, content, createdAt: Date.now(), agent });
          }
        } catch (e) { console.warn(`Failed to fetch ${endpoint}`, e); }
      }
    };

    if (['planner', 'engineer', 'complete'].includes(stage)) {
      await fetchArtifact('PRD', 'prd', 'Product Requirements Document', 'PM Agent', normalizePrd);
    }
    if (['engineer', 'complete'].includes(stage)) {
      await fetchArtifact('PLAN', 'plan', 'Execution Plan', 'Planner Agent', normalizePlan);
    }
    if (status === 'COMPLETED') {
      await fetchArtifact('CODE', 'code', 'Source Code', 'Engineer Agent', (raw) => {
        // Inject engineer tasks from result
        const project = this.getProject(projectId);
        if (project) project.engineerTasks = buildTasksFromResult(raw);
        return normalizeCode(raw);
      });
    }
  }
}

export const backend = new BackendService();
